package com.example.demo.DataAccess.Services;

import com.example.demo.DataAccess.Entity.DataProductStore;
import com.example.demo.DataAccess.Entity.DataProductType;
import com.example.demo.DataAccess.Entity.DataStore;
import com.example.demo.DataAccess.Repository.ProductTypeRepository;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class ProductTypeService {
    private static final Logger logger = Logger.getLogger(ProductTypeService.class);

    private final ProductTypeRepository productTypeRepository;

    @Autowired
    public ProductTypeService(ProductTypeRepository productTypeRepository) {
        this.productTypeRepository = productTypeRepository;
    }

    @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public boolean insertProductType(DataProductType productType) {
        try {
            DataProductType dataProductType = productTypeRepository.saveAndFlush(productType);
            //set the id's that were generated by db and store them to the data object
            productType.setProductTypeId(dataProductType.getProductTypeId());
            logger.info(String.format("inserted productType %s successfully to db", dataProductType.getProductName()));
            return true;
        } catch (Exception e) {
            logger.error(String.format("failed to insert productType %s into db, ERROR: %s", productType.getProductName(), e.getMessage()));
            return false;
        }
    }



   @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public boolean deleteProductType(int productTypeId){
        try{
            productTypeRepository.deleteById(productTypeId);
            logger.info(String.format("deleted productType %d successfully from db", productTypeId));
            return true;
        }catch (Exception e){
            logger.error(String.format("failed to delete productType %d from db, ERROR: %s", productTypeId, e.getMessage()));
            return false;
        }
    }

    @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public boolean updateProductType(DataProductType productType){
        try{
            Optional<DataProductType> dataProductType = productTypeRepository.findById(productType.getProductTypeId());
            if(dataProductType.isEmpty()){
                logger.warn(String.format("productType %d is not present in db", productType.getProductTypeId()));
                return false;
            }
            dataProductType.get().update(productType);
            productTypeRepository.save(dataProductType.get());
            logger.info(String.format("updated store %d successfully in db", dataProductType.get().getProductTypeId()));
            return true;
        }catch (Exception e){
            logger.error(String.format("failed to updated store %d in db, ERROR: %s", productType.getProductTypeId(), e.getMessage()));
            return false;
        }
    }

    @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public DataProductType getProductTypeById(int productTypeId) {
        try {
            Optional<DataProductType> dataProductType = productTypeRepository.findById(productTypeId);
            if(dataProductType.isEmpty()){
                logger.warn(String.format("productType %d is not present in db", productTypeId));
                return null;
            }
            logger.info(String.format("fetched productType %d successfully from db", dataProductType.get().getProductTypeId()));
            return dataProductType.get();
        } catch (Exception e) {
            logger.error(String.format("failed to fetch productType %d from db, ERROR: %s", productTypeId, e.getMessage()));
            return null;
        }
    }
    @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public List<DataProductType> getAllProductTypes() {
        try {
            List<DataProductType> productTypeList = productTypeRepository.findAll();
            logger.info("fetched all productTypes successfully from db");
            return productTypeList;
        } catch (Exception e) {
            logger.error(String.format("failed to fetch all productTypes from db, ERROR: %s", e.getMessage()));
            return null;
        }
    }

    @Transactional(rollbackFor = {Exception.class}, timeout = 10)
    public boolean updateProductRate(int productTypeId, int rate, int counterRate) {
        try {
            productTypeRepository.updateProductRate(productTypeId,rate,counterRate);
            logger.info(String.format("updated product type %d rate to %d successfully in db",
                    productTypeId,rate));

            return true;
        } catch (Exception e) {
            logger.error(String.format("failed to updated product type  %d to rate %d in db, ERROR: %s",
                    productTypeId,rate,
                    e.getMessage()));
            return false;
        }
    }

}
